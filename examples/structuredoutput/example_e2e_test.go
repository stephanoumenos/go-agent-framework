// ./examples/structuredoutput/example_e2e_test.go
//go:build e2e

package main

import (
	"context"
	"errors"
	gaf "go-agent-framework"
	"os"
	"testing"
	"time"

	// Provides core workflow definitions and execution.
	"go-agent-framework/nodes/openai" // Provides OpenAI nodes and dependency injection.
	"go-agent-framework/store"        // Provides storage options.

	goopenai "github.com/sashabaranov/go-openai" // OpenAI Go client.
	"github.com/stretchr/testify/assert"         // For assertions.
	"github.com/stretchr/testify/require"        // For setup checks and fatal assertions.
)

// TestStructuredOutputWorkflowE2E performs an end-to-end test of the
// structuredOutputWorkflowHandler using a real OpenAI client.
// It requires the OPENAI_API_KEY environment variable to be set.
// It verifies that the workflow completes successfully against the actual API
// and returns a Recipe struct with non-empty fields, demonstrating that the
// LLM successfully generated JSON conforming to the schema.
func TestStructuredOutputWorkflowE2E(t *testing.T) {
	apiKey := os.Getenv("OPENAI_API_KEY")
	if apiKey == "" {
		t.Skip("Skipping E2E test: OPENAI_API_KEY environment variable not set.")
	}
	// t.Parallel() // Avoid parallel execution for E2E tests using global DI state

	// --- Test Setup ---
	// 1. Add cleanup hook for DI state.
	t.Cleanup(func() {
		gaf.ResetDependencies()
	})

	// 2. Setup REAL OpenAI Client, Dependencies & Store
	realClient := goopenai.NewClient(apiKey)
	// Inject the real client into the global DI container.
	err := gaf.Dependencies(openai.Inject(realClient))
	require.NoError(t, err, "Failed to inject real dependencies")

	// Use a MemoryStore for simplicity in E2E test state management.
	memStore := store.NewMemoryStore()

	// 3. Define the Workflow using the production handler.
	workflowID := gaf.NodeID("recipeGeneratorWorkflowE2E")
	recipeWorkflowDef := gaf.WorkflowFromFunc(workflowID, structuredOutputWorkflowHandler)

	// 4. Prepare Input for the workflow.
	inputTopic := "Super quick and easy microwave chocolate mug cake, maybe vegan?"

	// 5. Execute Workflow - Use a longer timeout suitable for real API calls.
	ctx, cancel := context.WithTimeout(context.Background(), 120*time.Second) // Increased timeout.
	defer cancel()

	// Start the workflow lazily.
	// resultHandle := recipeWorkflowDef.Start(gaf.Into(inputTopic)) // Old way

	// Execute and wait for the result (Recipe struct).
	// recipeResult, err := gaf.Execute(ctx, resultHandle, gaf.WithStore(memStore)) // Old way
	recipeResult, err := gaf.ExecuteWorkflow(ctx, recipeWorkflowDef, inputTopic, gaf.WithStore(memStore)) // New way

	// --- Assertions ---
	// 6. Check for execution errors, prioritizing context errors.
	if errors.Is(err, context.DeadlineExceeded) {
		t.Fatalf("E2E test failed waiting for result: Timeout exceeded (%v)", ctx.Err())
	}
	if errors.Is(err, context.Canceled) {
		t.Fatalf("E2E test failed waiting for result: Context canceled (%v)", ctx.Err())
	}
	// Check for any other error returned by the workflow (e.g., API error, parsing error).
	require.NoError(t, err, "E2E Workflow execution failed unexpectedly")

	// 7. Assert that the returned Recipe struct fields are populated.
	// We check for non-empty values as the exact content generated by the LLM will vary.
	assert.NotEmpty(t, recipeResult.RecipeName, "RecipeName should not be empty")
	assert.NotEmpty(t, recipeResult.PrepTime, "PrepTime should not be empty")
	assert.NotEmpty(t, recipeResult.Ingredients, "Ingredients slice should not be empty")
	assert.NotEmpty(t, recipeResult.Steps, "Steps slice should not be empty")

	// Optional: Log the output for manual review or debugging.
	t.Logf("E2E Recipe Name: %s", recipeResult.RecipeName)
	t.Logf("E2E Prep Time: %s", recipeResult.PrepTime)
	t.Logf("E2E Ingredients: %v", recipeResult.Ingredients)
	t.Logf("E2E Steps: %v", recipeResult.Steps)
	t.Logf("E2E Description: %s", recipeResult.Description)
	t.Logf("E2E Servings: %d", recipeResult.Servings)
	t.Logf("E2E Difficulty: %s", recipeResult.Difficulty)

	// Add basic sanity checks on slice lengths.
	assert.Greater(t, len(recipeResult.Ingredients), 1, "Expected more than 1 ingredient")
	assert.Greater(t, len(recipeResult.Steps), 1, "Expected more than 1 step")
}
